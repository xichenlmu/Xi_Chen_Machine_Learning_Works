# -*- coding: utf-8 -*-
"""Xi_Chen_6070_CA01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E471wLQcsaOUxG6XzBFTQeLwJjhudvM9
"""

# import libraries for later use
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# load the house-price-train.csv dataset and save it as df
df = pd.read_csv('https://github.com/ArinB/MSBA-CA-Data/raw/main/CA01/house-price-train.csv')

"""**Part 1 Data Understanding**"""

# print the first a few rows to check data
print(df.head(5))

# print the shape of dataframe
print(df.shape)

# display all columns when checking dataframe
pd.set_option('display.max_rows',None)

# print the types of dataframe
print(df.dtypes)

# check for missing values for each column
print(df.isnull().sum())

# visualization of the distribution of a numerical column
plt.hist(df['SaleType'])
plt.show()

# visualization of the distribution of a categorical column
df['HouseStyle'].value_counts().plot(kind = 'bar')
plt.xticks(rotation = 30)
plt.show()

# group the data by a categorical column and calculate statistics
group_df = df.groupby('HouseStyle')['SalePrice'].mean().round(2)
print(group_df)

# create a bar plot to visualize the mean of a numeric column for each category of a categorical column
group_df = df.groupby('HouseStyle')['SalePrice'].mean()
group_df.plot(kind = 'bar')
plt.ylabel('Average Age')
plt.show()

# create a pivot table to summarize the data based on one condition numeric column
# Question: For each style of the house, what is the SalePrice average by HouseStyle
pivot_table = df.pivot_table(columns = 'HouseStyle', values = 'SalePrice', aggfunc = 'mean')
print(pivot_table)

# create a box plot to visualize the distribution of a numeric column by the categories of a categorical column
sns.boxplot(x = 'HouseStyle', y = 'SalePrice', data = df)
plt.ylabel('SalePrice')
plt.show()

# Choose the proper columns for later heatmap visualization
HeatMap_col = ['SalePrice', 'LotArea', 'YearBuilt', 'FullBath', 'HalfBath', 'GarageArea']
df[HeatMap_col].head(5)

# Set correlation for chosen columns for later heatmap visualization
cor_HeatMap_col = df[HeatMap_col].corr()
cor_HeatMap_col

# create a heatmap to visualize the correlation between multiple columns
plt.figure(figsize = (12, 8))
sns.heatmap(cor_HeatMap_col.corr(), cmap = 'RdYlGn', annot = True)
plt.show()

# create a scatter plot to visualize the relationship between two numeric columns
plt.scatter(df['YearBuilt'], df['SalePrice'])
plt.xlabel('YearBuilt')
plt.ylabel('SalePrice')
plt.show()

# create a scatter plot to visualize the relationship between two numeric columns
plt.scatter(df['GarageArea'], df['SalePrice'])
plt.xlabel('GarageArea')
plt.ylabel('SalePrice')
plt.show()

# create a box plot to visualize the distribution of a numeric column
plt.boxplot(df['LotArea'])
plt.ylabel('LotArea')
plt.show()

# create a scatter plot matrix to visualize the relationships between multiple numeric columns
from pandas.plotting import scatter_matrix
scatter_matrix(df[['SalePrice', 'LotArea', 'YearBuilt', 'FullBath', 'HalfBath', 'GarageArea']], 
               alpha = 0.2, figsize = (10, 10))
plt.show()

"""**Part 2 Data Pre-processing**"""

# create a copy of the original DataFrame
df_prep = df.copy()

# check data types
print(df_prep.dtypes)

# formatting all columns with object type in the dataset to strings
obj = df_prep.select_dtypes(include = np.object).columns.tolist()
df_prep[obj] = df_prep[obj].astype('string')

# check correct format types
print(df_prep.dtypes)

# display the percentages of columns with missing values
print(df_prep.isnull().sum()/len(df_prep))

# filling NA values for a numeric column with the mean value
df_prep['LotFrontage'] = df_prep['LotFrontage'].fillna(df_prep['LotFrontage'].mean())

# drop the columns with missing values over certain percentage
df_prep.drop(['Alley', 'FireplaceQu', 'PoolQC', 'Fence', 'MiscFeature'], 
             axis = 1, inplace = True)

# drop all rows with missing values remaining in the dataset
df_prep.dropna(axis = 0, how = 'any', inplace = True)

# check changes after cleaning missing values
print(df_prep.isnull().sum()/len(df_prep))

# drop duplicates in the dataset
df_prep = df_prep.drop_duplicates()

# drop outliers on specific columns based on the boxplot & scatter plot output 
df_prep = df_prep.drop(df_prep[df_prep['SalePrice'] > 600000].index)
df_prep = df_prep.drop(df_prep[df_prep['LotArea'] > 100000].index)

# check dataset size after dropping
print(df_prep.shape)
# The original dataset had 1460 records, and after dropping it now has 1330
# which is aceptable after cleanning.

# encode categorical variables using one-hot encoding
df_clean = df_prep.copy()
df_prep2 = pd.get_dummies(df_clean, columns = ['HouseStyle', 'SaleCondition'], 
                          prefix = ['HouseStyle', 'SaleCondition'])
print(df_prep2.head())

# standardize the values of a numeric column
from sklearn.preprocessing import StandardScaler
sclr = StandardScaler()
df_prep2['Sale_scaled'] = sclr.fit_transform(df_clean[['SalePrice']])
print(df_prep2['Sale_scaled'].head())

# bin the values of a numeric column
from sklearn.preprocessing import KBinsDiscretizer
dctr = KBinsDiscretizer(n_bins = 3, encode = 'ordinal')
df_prep2['Sale_binned'] = dctr.fit_transform(df_clean[['SalePrice']])
print(df_prep2.head())

# apply a min-max scaling to a numeric column
from sklearn.preprocessing import MinMaxScaler
sclr2 = MinMaxScaler()
df_prep2['Sale_scaled_minmax'] = sclr2.fit_transform(df_clean[['SalePrice']])
print(df_prep2.head())

# calculate summary statistics for a numeric column
print(df_clean['SalePrice'].describe())

# calculate the skewness and kurtosis of a numeric column
print(df_clean['SalePrice'].skew())
print(df_clean['SalePrice'].kurtosis())

# calculate the correlation between two numeric columns
print(df_clean['SalePrice'].corr(df['GarageArea']))

# calculate the correlation between two numeric columns
print(df_clean['SalePrice'].corr(df['LotArea']))

# calculate the correlation between two numeric columns
print(df_clean['SalePrice'].corr(df['YearBuilt']))

# use a t-test to compare the means of two numeric columns
from scipy.stats import ttest_ind
t, p = ttest_ind(df_clean['SalePrice'], df_clean['GarageArea'])
print(t, p)
# reject the null hypothesis & test is statistically significant

# use an ANOVA test to compare the means of multiple numeric columns
from scipy.stats import f_oneway
f, p = f_oneway(df_clean['SalePrice'], 
                df_clean['GarageArea'], 
                df_clean['YearBuilt'])
print(f, p)
# reject the null hypothesis & test is statistically significant

"""**Part 3 Data Post Processing (Collinearity)**"""

# group the fixed & the most-related columns based on previous statistics
# also create correlation table for the chosen columns
GroupedCol = ['SalePrice', 'LotArea', 'YearBuilt', 'GarageArea']
df_clean[GroupedCol].head(5)
cor_GroupedCol = df_clean[GroupedCol].corr()
cor_GroupedCol
# the values of correlation are changed compare to previous

# create a heatmap to visualize the correlation between the chosen columns
plt.figure(figsize = (12, 8))
sns.heatmap(cor_GroupedCol.corr(), cmap = 'RdYlGn', annot = True)
plt.show()
# we found that the corr value for GarageArea has decreased and becomes
# less related to the SalePrice, but still related. On the other hand,
# lotArea has increase and become more related to the SalePrice after
# Correcting missing values and outliers, the pre-porcessing step.

# create a scatter plot to visualize the relationship between two numeric columns
plt.scatter(df_clean['YearBuilt'], df_clean['SalePrice'])
plt.xlabel('YearBuilt')
plt.ylabel('SalePrice')
plt.show()
# outliers have been removed, the scale of graph has zoomed in

# create a scatter plot to visualize the relationship between two numeric columns
plt.scatter(df_clean['GarageArea'], df_clean['SalePrice'])
plt.xlabel('GarageArea')
plt.ylabel('SalePrice')
plt.show()
# by removing the outliers and missing values, the graph now showing dots are 
# more connected and concentrated

# create a box plot to visualize the distribution of a numeric column
plt.boxplot(df_clean['LotArea'])
plt.ylabel('LotArea')
plt.show()
# points or dots on the boxplot graph are more connected and closed to each other
# after the removal of outliers.

# create a scatter plot matrix to visualize the relationships between multiple numeric columns
scatter_matrix(df_clean[['SalePrice', 'LotArea', 'YearBuilt', 'GarageArea']], 
               alpha = 0.2, figsize = (10, 10))
plt.show()
# scatter plots are more detailed and clear after foucusing on the specific 
# fixed columns after data pre-processing